# CryptoLens 项目数据库设计方案 (基于 TimescaleDB 优化)

## 核心思路：星型时序模型 (Star Time-Series Model)

本设计采用以`symbols`（币种）表为中心的**星型模型**，通过 `symbol_id` (整数ID) 关联所有时序数据表（如 `kline_1m`, `metrics_5m`）。

针对海量数据表，我们**不使用**原生的 PostgreSQL 分区，而是采用 **TimescaleDB 扩展**，将其转换为 `Hypertable`，以实现自动分区、高性能查询和高倍率数据压缩。

---

## 一、数据模型层 (Schema)

此层负责定义数据关系和完整性。

1.  **中心维度表 (`symbols`)**:
    * **用途**: 统一管理所有币种信息（如 'BTCUSDT'）。
    * **设计**: 使用 `symbol_id` (SMALLINT, 小整数) 作为自增主键。
    * **约束**: `symbol_name` 字段（如 'BTCUSDT'）被设为 `UNIQUE` (唯一)，杜绝币种重复。

2.  **时序事实表 (`kline_1m`, `metrics_5m`)**:
    * **用途**: 存储 1 分钟 K 线和 5 分钟指标数据。
    * **设计**:
        * **专表专用**: K 线和指标数据分离在各自的表中。
        * **ID 关联**: 表中**不存储** 'BTCUSDT' 字符串，仅存储 `symbol_id` (SMALLINT) 作为外键关联 `symbols` 表。
        * **数据精度**: 所有价格、成交量、指标数据均使用 `DECIMAL` (numeric) 类型，保证金融计算的精度。

3.  **标准事实表 (`funding_rate`)**:
    * **用途**: 存储资金费率。
    * **设计**: 因数据量小（每天几次），使用标准 PostgreSQL 表，不转换为 Hypertable，效率更高。

## 二、性能与存储层 (TimescaleDB)

此层是我们方案的核心，负责处理海量数据的写入、查询和存储。

1.  **自动时序分区 (Hypertable)**:
    * **对象**: `kline_1m` 和 `metrics_5m` 表。
    * **策略**: 已将这两张表转换为 Hypertable，并设置 `chunk_time_interval` (分区间隔) 为 **`1 week` (一周)**。
    * **优势**:
        * **自动管理**: TimescaleDB 自动创建和管理按周分割的分区（Chunks）。
        * **高性能写入**: 新数据始终写入最新的分区，避免了索引膨胀。
        * **极速查询**: 按时间范围（如查询最近一天）的请求，数据库只需扫描对应的1-2个分区，速度极快。

2.  **原生压缩 (Compression) - 关键优化**:
    * **对象**: `kline_1m` 和 `metrics_5m` 表。
    * **策略**: 启用 `timescaledb.compress`，并添加策略自动压缩 `7 days` (七天) 前的历史数据。
    * **优势 (1) - 存储**: K 线和指标这类时序数据压缩率极高（通常 > 90%），极大节省存储成本。
    * **优势 (2) - 查询**: 压缩时按 `symbol_id` 分组 (`compress_segmentby = 'symbol_id'`)。这使得查询特定币种（如 "BTCUSDT" 的全年历史数据）时，数据库能以极高的效率批量读取已分组的压缩数据。

## 三、扩展与维护层 (Scalability)

此层确保架构能应对未来的业务增长。

1.  **币种扩展 (应对 10-20+ 新币种)**:
    * **路径**: 零 DDL (数据库结构) 修改。
    * **操作**: 只需向 `symbols` 中心表 `INSERT` 新的币种行。
    * **结果**: `kline_1m` 等所有 Hypertable **无需任何改动**，即可开始接受新币种（携带新的 `symbol_id`）的数据。

2.  **数据类型扩展 (应对新数据)**:
    * **路径**: 零侵入。
    * **操作**: 若需添加“清算数据”，只需新建一张 `liquidations` 表，同样包含 `symbol_id` 和时间字段。
    * **结果**: 如果新数据量大，可将其同样转换为 Hypertable (`SELECT create_hypertable(...)`)，无缝融入现有架构，且不影响任何现有表的性能。

3.  **数据完整性**:
    * **设计**: 在 `kline_1m` 和 `metrics_5m` 表上均创建了 `UNIQUE` 复合索引 `(symbol_id, time)`。
    * **优势**: 从数据库层面保证了“同一币种在同一时间”只能有一条 K 线或指标数据，确保了数据的唯一性和准确性。

---

## 表 1: 币종信息表 (symbols)

``` 
/* * 
 * 作用: 统一管理所有交易对, 应对未来币种扩展。
 */
CREATE TABLE symbols (
    -- SMALLINT (2字节) 足以支持超过3万个币种, 高效
    symbol_id SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    
    -- 交易对名称, 设为 UNIQUE 保证不重复
    symbol_name VARCHAR(30) UNIQUE NOT NULL, 
    
    -- (可选) 描述性字段
    base_asset VARCHAR(10),
    quote_asset VARCHAR(10),
    description TEXT,
    
    added_at TIMESTAMT_Z DEFAULT NOW()
);

-- 为名称查询创建索引
CREATE INDEX idx_symbols_symbol_name ON symbols(symbol_name);

-- 插入你的初始币种 (你会得到 symbol_id 1, 2, 3)
INSERT INTO symbols (symbol_name, base_asset, quote_asset) VALUES
('BTCUSDT', 'BTC', 'USDT'),
('ETHUSDT', 'ETH', 'USDT'),
('SOLUSDT', 'SOL', 'USDT');
```

---

##  表 2: 1分钟 K线表 (kline_1m)

``` 
/* *
 * 作用: 存储所有币种的1分钟K线。
 * 设计: 它将是一个 TimescaleDB Hypertable。
 */
CREATE TABLE kline_1m (
    -- K线开盘时间, 作为 Hypertable 的时间维度
    -- TIMESTAMPTZ 是带时区的标准时间戳, 强烈推荐
    open_time TIMESTAMPTZ NOT NULL, 
    
    -- 外键, 关联 symbols 表
    -- ON DELETE CASCADE 意味着如果 symbols 表中的币种被删除,
    -- 所有相关的K线数据也会被自动清除。
    symbol_id SMALLINT NOT NULL REFERENCES symbols(symbol_id) ON DELETE CASCADE, 
    
    -- K线核心数据 (使用 DECIMAL 保证金融精度)
    -- (20, 8) 表示总共20位数, 其中8位是小数
    open DECIMAL(20, 8), 
    high DECIMAL(20, 8),
    low DECIMAL(20, 8),
    close DECIMAL(20, 8),
    volume DECIMAL(30, 8), -- 成交量
    
    -- K线附加数据 (来自你的CSV示例)
    close_time TIMESTAMPTZ NOT NULL, -- K线关闭时间
    quote_volume DECIMAL(30, 8), -- 成交额
    trades INT, -- 成交笔数
    taker_buy_volume DECIMAL(30, 8), -- 主动买入量
    taker_buy_quote_volume DECIMAL(30, 8) -- 主动买入额
);

-- !! 关键步骤: 将 kline_1m 转换成 Hypertable
-- TimescaleDB 会自动按 'open_time' 创建分区 (chunks)
SELECT create_hypertable(
    'kline_1m',  -- 目标表名
    'open_time', -- 按这个时间字段分区
    
    -- 自动按月创建分区 (chunk)。
    -- 如果你每天的数据量特别巨大 (例如 >10GB), 也可以设为 '1 week' 或 '1 day'
    chunk_time_interval => INTERVAL '1 week'
);

-- 创建唯一索引, 保证 (币种+时间) 不重复
-- 这对于 Hypertable 来说是最佳实践, 也能极大提升查询速度
CREATE UNIQUE INDEX idx_kline_symbol_time ON kline_1m (symbol_id, open_time);


/* * (可选, 但强烈推荐): 添加压缩策略
 * K线数据是 "Append-Only" (只追加, 不修改), 压缩率极高 (可达 90%+)
 * 这能帮你节省巨额的存储成本
 */
 
-- 1. 启用压缩, 并告诉它按 symbol_id 分组压缩 (提升查询效率)
ALTER TABLE kline_1m SET (
  timescaledb.compress,
  timescaledb.compress_segmentby = 'symbol_id'
);

-- 2. 添加策略: 自动压缩 7 天前的旧数据
-- (你可以按需调整, 比如 '1 day' 或 '30 days')
SELECT add_compression_policy('kline_1m', INTERVAL '7 days');
```

---

## 表 3: 资金费率表 (funding_rate)

``` 
/* * 
 * 作用: 存储各币种的费率。
 * 设计: 标准 PostgreSQL 表, 因为数据量不大。
 */
CREATE TABLE funding_rate (
    -- 费率计算时间
    calc_time TIMESTAMPTZ NOT NULL,
    
    -- 关联的币种 ID
    symbol_id SMALLINT NOT NULL REFERENCES symbols(symbol_id) ON DELETE CASCADE,
    
    -- 间隔 (例如 8)
    interval_hours SMALLINT, 
    
    -- 费率 (精度要求高, 20位总数, 10位小数)
    funding_rate DECIMAL(20, 10), 
    
    -- 复合主键, 保证 (币种+时间) 唯一性, 也能加快查询
    PRIMARY KEY (symbol_id, calc_time)
);
```

---

## 表 4: 5分钟指标表 (metrics_5m)

``` 
/* * 表 4: 5分钟指标表 (metrics_5m)
 * 作用: 存储未平仓合约、多空比等指标。
 * 设计: TimescaleDB Hypertable, 因为数据量也很大。
 */
CREATE TABLE metrics_5m (
    -- 指标创建时间, 作为 Hypertable 的时间维度
    create_time TIMESTAMPTZ NOT NULL,
    
    -- 关联的币种 ID
    symbol_id SMALLINT NOT NULL REFERENCES symbols(symbol_id) ON DELETE CASCADE,
    
    -- 指标数据 (来自你的CSV示例, 使用高精度 DECIMAL)
    sum_open_interest DECIMAL(30, 8),
    sum_open_interest_value DECIMAL(30, 8),
    count_toptrader_long_short_ratio DECIMAL(30, 10),
    sum_toptrader_long_short_ratio DECIMAL(30, 10),
    count_long_short_ratio DECIMAL(30, 10),
    sum_taker_long_short_vol_ratio DECIMAL(30, 10)
);

-- !! 关键步骤: 将 metrics_5m 转换成 Hypertable
SELECT create_hypertable(
    'metrics_5m', 
    'create_time', -- 按这个时间字段分区
    
    -- 参照 kline_1m 的设置, 我们同样使用 '1 week' (1周) 作为分区周期
    chunk_time_interval => INTERVAL '1 week'
);

-- 创建唯一索引, 保证 (币种+时间) 不重复
CREATE UNIQUE INDEX idx_metrics_symbol_time ON metrics_5m (symbol_id, create_time);

/* * (可选, 但强烈推荐): 添加压缩策略
 * 指标数据同样适合压缩
 */
 
-- 1. 启用压缩, 并按 symbol_id 分组
ALTER TABLE metrics_5m SET (
  timescaledb.compress,
  timescaledb.compress_segmentby = 'symbol_id'
);

-- 2. 添加策略: 自动压缩 7 天前的旧数据
SELECT add_compression_policy('metrics_5m', INTERVAL '7 days');
```